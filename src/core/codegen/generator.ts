import {
  MethodDeclarationStructure,
  OptionalKind,
  Project,
  SourceFile,
} from "ts-morph";
import { z } from "zod";
import { makeGetterStatements, makeSetterStatements } from "./statements";

export class EntityGenerator {
  private project: Project;
  public targetFile: SourceFile;
  private readonly models: z.ZodObject<any>[];
  constructor(private readonly pathToModels: string, outputPath: string) {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(outputPath, undefined, {
      overwrite: true,
    });
    this.models = require(this.pathToModels);
  }

  public generateImports() {
    this.targetFile.addImportDeclaration({
      namedImports: ["z"],
      moduleSpecifier: "zod",
    });
    this.targetFile.addImportDeclaration({
      namedImports: ["Entity", "KeyAccessError"],
      moduleSpecifier: "../../core/engine",
    });
    this.targetFile.addImportDeclaration({
      namedImports: [...Object.keys(this.models)],
      moduleSpecifier: "../models",
    });
    this.targetFile.addImportDeclaration({
      namedImports: ["SQLiteStore as Store"],
      moduleSpecifier: "../../core/store",
    });
    this.targetFile.addImportDeclaration({
      namedImports: ["formatModifiers"],
      moduleSpecifier: "../../core/format",
    });
  }

  public generateTypeForSchema(name: string) {
    this.targetFile.addTypeAlias({
      name: name + "Model",
      type: `z.infer<typeof ${name}Schema>`,
    });
  }

  public generateClassForSchema(name: string, schema: z.ZodObject<any>) {
    const methods: OptionalKind<MethodDeclarationStructure>[] = [];

    methods.push({
      name: "load",
      isStatic: true,
      parameters: [
        {
          name: "id",
          type: "string",
        },
      ],
      returnType: `${name} | null`,
      statements: [
        `const data = store.get<${name}Model>("${name.toLowerCase()}", id);`,
        `if (!data) {`,
        `   return new ${name}(id);`,
        `}`,
        `return new ${name}(id, data);`,
      ],
    });

    for (const key in schema.shape) {
      const type = `${name}Model["${key}"]`;
      const isNullable = schema.shape[key].isNullable();
      const isBoolean = schema.shape[key].isBoolean();
      methods.push({
        name: `get ${key}`,
        returnType: type,
        statements: makeGetterStatements({
          key,
          name,
          isNullable,
          isBoolean,
        }),
      });
      methods.push({
        name: `set ${key}`,
        parameters: [{ name: "value", type }],
        statements: makeSetterStatements(key),
      });
    }

    this.targetFile.addClass({
      name,
      isExported: true,
      extends: `Entity<${name}Model, typeof ${name}Schema>`,
      ctors: [
        {
          parameters: [
            {
              name: "id",
              type: "string",
            },
            {
              name: "data",
              type: `${name}Model`,
              hasQuestionToken: true,
            },
          ],
          statements: [
            `super(id, ${name}Schema, store)`,
            `this.data = { id, ...data } || {};`,
          ],
        },
      ],
      methods,
    });
  }

  public generateDefinitionsForModel(name: string, schema: z.ZodObject<any>) {
    this.generateTypeForSchema(name);
    this.generateClassForSchema(name, schema);
  }

  public generateGlobalDefinitions() {
    this.targetFile.addTypeAlias({
      name: "SchemaNames",
      type: Object.keys(this.models)
        .map((key) => `"${key.toLowerCase().replace("schema", "")}"`)
        .join(" | "),
    });
  }

  public generateStore() {
    this.targetFile.addStatements([
      `export const store = new Store<SchemaNames>("", {`,
      ...Object.keys(this.models).map(
        (key) => `  ${key.replace("Schema", "").toLowerCase()}: ${key},`
      ),
      `});`,
    ]);
    // this.targetFile.addVariableStatement({
    //   declarationKind: VariableDeclarationKind.Const,
    //   declarations: [
    //     {
    //       name: "store",
    //       initializer: `new Store<SchemaNames>("", schemaLookup)`,
    //       // .reduce(
    //       //   (acc, key) => ({
    //       //     ...acc,
    //       //     [key.replace("Schema", "").toLowerCase()]: key,
    //       //   }),
    //       //   {}
    //       // )
    //       // .toString()}})`,
    //     },
    //   ],
    // });
  }

  public generate() {
    this.generateImports();
    this.generateGlobalDefinitions();
    this.generateStore();
    for (const name in this.models) {
      this.generateDefinitionsForModel(
        name.replace("Schema", ""),
        this.models[name]
      );
    }
    this.targetFile.prependWhitespace("\n\n");
    this.targetFile.insertText(
      0,
      "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY."
    );
  }
}
