import { EntityGenerator } from "../../src/commands/codegen/generators/entity.generator";
import os from "os";
import { z } from "zod";
import * as fs from "fs";

const TestSchema = z.object({
  id: z.string(),
  name: z.string(),
  age: z.number(),
  address: z.string(),
});

describe("Entity Generator", () => {
  let generator: EntityGenerator;
  let outputPath: string;

  beforeEach(() => {
    outputPath = os.tmpdir() + "/schema.ts";
    generator = new EntityGenerator({
      models: { test: TestSchema },
      outputPath,
    });
  });

  it("should generate an entity & model definition for a schema with a nullable field", () => {
    generator.generateDefinitionsForModel("Test", TestSchema);
    expect(generator.targetFile.getFullText()).toMatchInlineSnapshot(`
      "type TestModel = z.infer<typeof TestSchema>;

      export class Test extends Entity<TestModel, typeof TestSchema> {
          constructor(id: string, data?: TestModel) {
              super(id, TestSchema, store)
              this.data = { id, ...data } || {};
          }

          static load(id: string): Test | null {
              const data = store.get<TestModel>("test", id);
              if (!data) {
                 return new Test(id);
              }

              return new Test(id, data);
          }

          get id(): TestModel["id"] {
              const value = this.get("id")
              if (typeof value === "undefined") {
                throw new KeyAccessError<Test>("id")
              }

              return value
          }

          set id(value: TestModel["id"]) {
              this.set("id", value);
          }

          get name(): TestModel["name"] {
              const value = this.get("name")
              if (typeof value === "undefined") {
                throw new KeyAccessError<Test>("name")
              }

              return value
          }

          set name(value: TestModel["name"]) {
              this.set("name", value);
          }

          get age(): TestModel["age"] {
              const value = this.get("age")
              if (typeof value === "undefined") {
                throw new KeyAccessError<Test>("age")
              }

              return value
          }

          set age(value: TestModel["age"]) {
              this.set("age", value);
          }

          get address(): TestModel["address"] {
              const value = this.get("address")
              if (typeof value === "undefined") {
                throw new KeyAccessError<Test>("address")
              }

              return value
          }

          set address(value: TestModel["address"]) {
              this.set("address", value);
          }
      }
      "
    `);
  });

  it("should generate a global type for all schemas", () => {
    generator.generateGlobalDefinitions();
    expect(generator.targetFile.getFullText()).toMatchInlineSnapshot(`
      "type SchemaNames = "test";
      "
    `);
  });
  it("should generate the full type set", () => {
    generator.generate({
      shouldSave: true,
    });
    expect(generator.targetFile.getFullText()).toMatchInlineSnapshot(`
      "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

      import { z } from "zod";
      import { Entity, KeyAccessError, SQLiteStore as Store } from "@heaps/engine";
      import { test } from "../../models";

      type SchemaNames = "test";
      export const store = new Store<SchemaNames>("", {
        test: test,
      });

      type testModel = z.infer<typeof testSchema>;

      export class test extends Entity<testModel, typeof testSchema> {
          constructor(id: string, data?: testModel) {
              super(id, testSchema, store)
              this.data = { id, ...data } || {};
          }

          static load(id: string): test | null {
              const data = store.get<testModel>("test", id);
              if (!data) {
                 return new test(id);
              }

              return new test(id, data);
          }

          get id(): testModel["id"] {
              const value = this.get("id")
              if (typeof value === "undefined") {
                throw new KeyAccessError<test>("id")
              }

              return value
          }

          set id(value: testModel["id"]) {
              this.set("id", value);
          }

          get name(): testModel["name"] {
              const value = this.get("name")
              if (typeof value === "undefined") {
                throw new KeyAccessError<test>("name")
              }

              return value
          }

          set name(value: testModel["name"]) {
              this.set("name", value);
          }

          get age(): testModel["age"] {
              const value = this.get("age")
              if (typeof value === "undefined") {
                throw new KeyAccessError<test>("age")
              }

              return value
          }

          set age(value: testModel["age"]) {
              this.set("age", value);
          }

          get address(): testModel["address"] {
              const value = this.get("address")
              if (typeof value === "undefined") {
                throw new KeyAccessError<test>("address")
              }

              return value
          }

          set address(value: testModel["address"]) {
              this.set("address", value);
          }
      }
      "
    `);
  });
  it("should generate the full type set with a custom output path", () => {
    generator.generate({
      shouldSave: true,
    });
    expect(generator.targetFile.getFullText()).toMatch(
      fs.readFileSync(outputPath, "utf-8")
    );
  });
});
