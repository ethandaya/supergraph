import {
  MethodDeclarationStructure,
  OptionalKind,
  Project,
  SourceFile,
} from "ts-morph";
import { z } from "zod";
import { makeGetterStatements, makeSetterStatements } from "./statements";

type GenerateOptions = {
  shouldSave: boolean;
};

type EntityGeneratorOptions = {
  models: { [key: string]: z.AnyZodObject };
  outputPath: string;
};

export class EntityGenerator {
  private project: Project;
  public targetFile: SourceFile;
  private readonly models: {
    [key: string]: z.AnyZodObject;
  } = {};

  constructor(options: EntityGeneratorOptions) {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(
      options.outputPath,
      undefined,
      {
        overwrite: true,
      }
    );
    this.models = options.models;
  }

  public generateImports() {
    this.targetFile.addImportDeclaration({
      namedImports: ["z"],
      moduleSpecifier: "zod",
    });
    this.targetFile.addImportDeclaration({
      namedImports: ["Entity", "KeyAccessError", "SQLiteStore as Store"],
      moduleSpecifier: "@heaps/engine",
    });
    this.targetFile.addImportDeclaration({
      namedImports: [...Object.keys(this.models)],
      moduleSpecifier: "../models",
    });
  }

  public generateTypeForSchema(name: string) {
    this.targetFile.addTypeAlias({
      name: name + "Model",
      type: `z.infer<typeof ${name}Schema>`,
    });
  }

  public generateClassForSchema(name: string, schema: z.ZodObject<any>) {
    const methods: OptionalKind<MethodDeclarationStructure>[] = [];

    methods.push({
      name: "load",
      isStatic: true,
      parameters: [
        {
          name: "id",
          type: "string",
        },
      ],
      returnType: `${name} | null`,
      statements: [
        `const data = store.get<${name}Model>("${name.toLowerCase()}", id);`,
        `if (!data) {`,
        `   return new ${name}(id);`,
        `}`,
        `return new ${name}(id, data);`,
      ],
    });

    for (const key in schema.shape) {
      const type = `${name}Model["${key}"]`;
      const isNullable = schema.shape[key].isNullable();
      methods.push({
        name: `get ${key}`,
        returnType: type,
        statements: makeGetterStatements({
          key,
          name,
          isNullable,
        }),
      });
      methods.push({
        name: `set ${key}`,
        parameters: [{ name: "value", type }],
        statements: makeSetterStatements(key),
      });
    }

    this.targetFile.addClass({
      name,
      isExported: true,
      extends: `Entity<${name}Model, typeof ${name}Schema>`,
      ctors: [
        {
          parameters: [
            {
              name: "id",
              type: "string",
            },
            {
              name: "data",
              type: `${name}Model`,
              hasQuestionToken: true,
            },
          ],
          statements: [
            `super(id, ${name}Schema, store)`,
            `this.data = { id, ...data } || {};`,
          ],
        },
      ],
      methods,
    });
  }

  public generateDefinitionsForModel(name: string, schema: z.ZodObject<any>) {
    this.generateTypeForSchema(name);
    this.generateClassForSchema(name, schema);
  }

  public generateGlobalDefinitions() {
    this.targetFile.addTypeAlias({
      name: "SchemaNames",
      type: Object.keys(this.models)
        .map((key) => `"${key.toLowerCase().replace("schema", "")}"`)
        .join(" | "),
    });
  }

  public generateStore() {
    this.targetFile.addStatements([
      `export const store = new Store<SchemaNames>("", {`,
      ...Object.keys(this.models).map(
        (key) => `  ${key.replace("Schema", "").toLowerCase()}: ${key},`
      ),
      `});`,
    ]);
  }

  public generate(options: GenerateOptions = { shouldSave: true }) {
    this.generateImports();
    this.generateGlobalDefinitions();
    this.generateStore();
    for (const name in this.models) {
      this.generateDefinitionsForModel(
        name.replace("Schema", ""),
        this.models[name]
      );
    }
    this.targetFile.prependWhitespace("\n\n");
    this.targetFile.insertText(
      0,
      "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY."
    );
    if (options.shouldSave) {
      this.save();
    }
  }

  public save() {
    this.targetFile.saveSync();
  }
}
