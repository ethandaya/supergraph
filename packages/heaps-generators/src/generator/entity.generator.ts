import {
  MethodDeclarationStructure,
  OptionalKind,
  Project,
  SourceFile,
} from "ts-morph";
import * as fs from "fs";
import { format } from "prettier";
import { z } from "zod";

type EntityGeneratorOptions = {
  isAsync: boolean;
  outputPath: string;
  storeImportPath: string;
  modelImportPath: string;
  models: { [key: string]: z.AnyZodObject };
};

type GetterStatementOptions = {
  key: string;
  name: string;
  isNullable: boolean;
};

export function makeGetterStatements({
  key,
  name,
  isNullable,
}: GetterStatementOptions) {
  return [
    `const value = this.get("${key}")`,
    `if (typeof value === "undefined"${
      isNullable ? " && value !== null" : ""
    }) {`,
    `  throw new KeyAccessError<${name}>("${key}")`,
    `}`,
    `return value`,
  ];
}

export function makeSetterStatements(key: string) {
  return `this.set("${key}", value);`;
}

export class EntityGenerator {
  private project: Project;
  public targetFile: SourceFile;

  constructor(private readonly options: EntityGeneratorOptions) {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(
      options.outputPath,
      undefined,
      { overwrite: true }
    );
  }
  public generateImports() {
    const imports = [
      {
        namedImports: ["z"],
        moduleSpecifier: "zod",
      },
      {
        namedImports: [
          `${this.options.isAsync ? "Async" : "Sync"}CrudEntity`,
          "KeyAccessError",
        ],
        moduleSpecifier: "@heaps/engine",
      },
      {
        namedImports: [...Object.keys(this.options.models)],
        moduleSpecifier: this.options.modelImportPath,
      },
      {
        namedImports: ["store"],
        moduleSpecifier: this.options.storeImportPath,
      },
    ];

    this.targetFile.addImportDeclarations(imports);
  }

  public generateTypeForModel(name: string) {
    this.targetFile.addTypeAlias({
      name: name + "Model",
      type: `z.infer<typeof ${name}Schema>`,
    });
  }

  public generateEntityForModel(name: string, schema: z.ZodObject<any>) {
    let methods: OptionalKind<MethodDeclarationStructure>[] = [];
    methods.push({
      name: "load",
      isStatic: true,
      isAsync: this.options.isAsync,
      parameters: [
        {
          name: "id",
          type: "string",
        },
      ],
      returnType: this.options.isAsync
        ? `Promise<${name} | null>`
        : `${name} | null`,
      statements: [
        `const data =${
          this.options.isAsync ? " await" : ""
        } store.get("${name}", id);`,
        `if (!data) {`,
        `   return new ${name}(id);`,
        `}`,
        `return new ${name}(id, data);`,
      ],
    });

    for (const key in schema.shape) {
      const type = `${name}Model["${key}"]`;
      const isNullable = schema.shape[key].isNullable();
      methods.push({
        name: `get ${key}`,
        returnType: type,
        statements: makeGetterStatements({
          key,
          name,
          isNullable,
        }),
      });
      methods.push({
        name: `set ${key}`,
        parameters: [{ name: "value", type }],
        statements: makeSetterStatements(key),
      });
    }

    this.targetFile.addClass({
      name,
      isExported: true,
      extends: `${
        this.options.isAsync ? "Async" : "Sync"
      }CrudEntity<"${name}", ${name}Model, typeof ${name}Schema>`,
      ctors: [
        {
          parameters: [
            {
              name: "id",
              type: "string",
            },
            {
              name: "data",
              type: `${name}Model`,
              hasQuestionToken: true,
            },
          ],
          statements: [
            `super(id, "${name}", ${name}Schema, store)`,
            `this._data = { id, ...data } || {};`,
          ],
        },
      ],
      methods,
    });
  }

  public generateDefinitionsForModel(name: string, schema: z.ZodObject<any>) {
    this.generateTypeForModel(name);
    this.generateEntityForModel(name, schema);
  }

  public generateGlobalDefinitions() {
    this.targetFile.addTypeAlias({
      isExported: true,
      name: "SchemaNames",
      type: Object.keys(this.options.models)
        .map((key) => `"${key.replace("Schema", "")}"`)
        .join(" | "),
    });
  }

  public generate(save = false) {
    this.generateImports();
    this.generateGlobalDefinitions();
    for (const name in this.options.models) {
      this.generateDefinitionsForModel(
        name.replace("Schema", ""),
        this.options.models[name]
      );
    }
    if (save) {
      const formatted = format(this.targetFile.getText(), {
        parser: "typescript",
      });
      const header = `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.`;
      fs.writeFileSync(this.options.outputPath, `${header}\n\n${formatted}`);
    }
  }
}
